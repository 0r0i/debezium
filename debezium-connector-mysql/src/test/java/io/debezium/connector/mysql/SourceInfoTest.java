/*
 * Copyright Debezium Authors.
 * 
 * Licensed under the Apache Software License version 2.0, available at http://www.apache.org/licenses/LICENSE-2.0
 */
package io.debezium.connector.mysql;

import static org.junit.Assert.assertTrue;

import org.apache.avro.Schema;
import org.fest.assertions.GenericAssert;
import org.junit.Test;

import io.confluent.connect.avro.AvroData;
import io.debezium.document.Document;

public class SourceInfoTest {

    private static int avroSchemaCacheSize = 1000;
    private static final AvroData avroData = new AvroData(avroSchemaCacheSize);

    /**
     * When we want to consume SinkRecord which generated by debezium-connector-mysql, it should not
     * throw error "org.apache.avro.SchemaParseException: Illegal character in: server-id"
     */
    @Test
    public void shouldValidateSourceInfoSchema() {
        org.apache.kafka.connect.data.Schema kafkaSchema = SourceInfo.SCHEMA;
        Schema avroSchema = avroData.fromConnectSchema(kafkaSchema);
        assertTrue(avroSchema != null);
    }

    @Test
    public void shouldConsiderPositionsWithSameGtidSetsAsSame() {
        assertPositionWithGtids("IdA:1-5").isAtOrBefore(positionWithGtids("IdA:1-5"));  // same, single
        assertPositionWithGtids("IdA:1-5,IdB:1-20").isAtOrBefore(positionWithGtids("IdA:1-5,IdB:1-20")); // same, multiple
        assertPositionWithGtids("IdA:1-5,IdB:1-20").isAtOrBefore(positionWithGtids("IdB:1-20,IdA:1-5")); // equivalent
    }

    @Test
    public void shouldConsiderPositionsWithSameGtidSetsAndSnapshotAsSame() {
        assertPositionWithGtids("IdA:1-5",true).isAtOrBefore(positionWithGtids("IdA:1-5",true));  // same, single
        assertPositionWithGtids("IdA:1-5,IdB:1-20",true).isAtOrBefore(positionWithGtids("IdA:1-5,IdB:1-20",true)); // same, multiple
        assertPositionWithGtids("IdA:1-5,IdB:1-20",true).isAtOrBefore(positionWithGtids("IdB:1-20,IdA:1-5",true)); // equivalent
    }

    @Test
    public void shouldOrderPositionWithGtidAndSnapshotBeforePositionWithSameGtidButNoSnapshot() {
        assertPositionWithGtids("IdA:1-5",true).isAtOrBefore(positionWithGtids("IdA:1-5"));  // same, single
        assertPositionWithGtids("IdA:1-5,IdB:1-20",true).isAtOrBefore(positionWithGtids("IdA:1-5,IdB:1-20")); // same, multiple
        assertPositionWithGtids("IdA:1-5,IdB:1-20",true).isAtOrBefore(positionWithGtids("IdB:1-20,IdA:1-5")); // equivalent
    }

    @Test
    public void shouldOrderPositionWithoutGtidAndSnapshotAfterPositionWithSameGtidAndSnapshot() {
        assertPositionWithGtids("IdA:1-5",false).isAfter(positionWithGtids("IdA:1-5",true));  // same, single
        assertPositionWithGtids("IdA:1-5,IdB:1-20",false).isAfter(positionWithGtids("IdA:1-5,IdB:1-20",true)); // same, multiple
        assertPositionWithGtids("IdA:1-5,IdB:1-20",false).isAfter(positionWithGtids("IdB:1-20,IdA:1-5",true)); // equivalent
    }

    @Test
    public void shouldOrderPositionWithGtidsAsBeforePositionWithExtraServerUuidInGtids() {
        assertPositionWithGtids("IdA:1-5").isBefore(positionWithGtids("IdA:1-5,IdB:1-20"));
    }

    @Test
    public void shouldOrderPositionsWithSameServerButLowerUpperLimitAsBeforePositionWithSameServerUuidInGtids() {
        assertPositionWithGtids("IdA:1-5").isBefore(positionWithGtids("IdA:1-6"));
        assertPositionWithGtids("IdA:1-5:7-9").isBefore(positionWithGtids("IdA:1-10"));
        assertPositionWithGtids("IdA:2-5:8-9").isBefore(positionWithGtids("IdA:1-10"));
    }

    @Test
    public void shouldOrderPositionWithoutGtidAsBeforePositionWithGtid() {
        assertPositionWithoutGtids("filename.01", Integer.MAX_VALUE, 0).isBefore(positionWithGtids("IdA:1-5"));
    }

    @Test
    public void shouldOrderPositionWithGtidAsAfterPositionWithoutGtid() {
        assertPositionWithGtids("IdA:1-5").isAfter(positionWithoutGtids("filename.01", 0, 0));
    }

    protected Document positionWithGtids(String gtids) {
        return positionWithGtids(gtids, false);
    }

    protected Document positionWithGtids(String gtids, boolean snapshot) {
        if (snapshot) {
            return Document.create(SourceInfo.GTID_KEY, gtids, SourceInfo.SNAPSHOT_KEY, true);
        }
        return Document.create(SourceInfo.GTID_KEY, gtids);
    }

    protected Document positionWithoutGtids(String filename, int position, int row) {
        return positionWithoutGtids(filename, position, row, false);
    }

    protected Document positionWithoutGtids(String filename, int position, int row, boolean snapshot) {
        if (snapshot) {
            return Document.create(SourceInfo.BINLOG_FILENAME_OFFSET_KEY, filename,
                                   SourceInfo.BINLOG_POSITION_OFFSET_KEY, position,
                                   SourceInfo.BINLOG_EVENT_ROW_NUMBER_OFFSET_KEY, row,
                                   SourceInfo.SNAPSHOT_KEY, true);
        }
        return Document.create(SourceInfo.BINLOG_FILENAME_OFFSET_KEY, filename,
                               SourceInfo.BINLOG_POSITION_OFFSET_KEY, position,
                               SourceInfo.BINLOG_EVENT_ROW_NUMBER_OFFSET_KEY, row);
    }

    protected PositionAssert assertThat(Document position) {
        return new PositionAssert(position);
    }

    protected PositionAssert assertPositionWithGtids(String gtids) {
        return assertThat(positionWithGtids(gtids));
    }

    protected PositionAssert assertPositionWithGtids(String gtids, boolean snapshot) {
        return assertThat(positionWithGtids(gtids, snapshot));
    }

    protected PositionAssert assertPositionWithoutGtids(String filename, int position, int row) {
        return assertPositionWithoutGtids(filename, position, row, false);
    }

    protected PositionAssert assertPositionWithoutGtids(String filename, int position, int row, boolean snapshot) {
        return assertThat(positionWithoutGtids(filename, position, row, snapshot));
    }

    protected static class PositionAssert extends GenericAssert<PositionAssert, Document> {
        public PositionAssert(Document position) {
            super(PositionAssert.class, position);
        }

        public PositionAssert isAt(Document otherPosition) {
            if (SourceInfo.isPositionAtOrBefore(actual, otherPosition)) return this;
            failIfCustomMessageIsSet();
            throw failure(actual + " should be consider same position as " + otherPosition);
        }

        public PositionAssert isBefore(Document otherPosition) {
            return isAtOrBefore(otherPosition);
        }

        public PositionAssert isAtOrBefore(Document otherPosition) {
            if (SourceInfo.isPositionAtOrBefore(actual, otherPosition)) return this;
            failIfCustomMessageIsSet();
            throw failure(actual + " should be consider same position as or before " + otherPosition);
        }

        public PositionAssert isAfter(Document otherPosition) {
            if (!SourceInfo.isPositionAtOrBefore(actual, otherPosition)) return this;
            failIfCustomMessageIsSet();
            throw failure(actual + " should be consider after " + otherPosition);
        }
    }
}
